##coding=utf-8

Mako 的运行时环境

本节会介绍一点模板中可访问的对象和内建函数的内容。
Context

Context 是模板被第一次执行前创建的一个核心对象，它负责和模板外部做所有的交互。它由两个主要的组件组成，1. 输出缓冲区，这是一个类似文件的对象，比如 Python 的 StringIO；2. 变量字典，其中的所有变量均可在模板中自由引用，该字典是由传递给 template.rener() 方法的参数，以及一些由 Mako 运行时环境提供的内建变量组成。
缓冲区

缓冲区存储在 Context 中，通过 context.write() 方法可以写缓冲区。通常你不需要关注此方法，因为模板中的文本和 ${} 形式的表达式，都会自动将输出提交到该方法。只有在下列几个应用场景下你才可能需要用到它：1. 处理各种过滤/缓冲（详见 Filtering and Buffering），2. 用编程的方式将内容发送到输出流，比如在一个 <％ ％> 块中。
<%
	context.write("some programmatic text")
%>
实际的缓冲区可能不是原来发送给 Context 对象的那个，因为在各种过滤/缓存的场景下，可能会 "push" 一个新的缓冲区到 context 内部的缓冲区栈上。正因为此，只要我们记住始终调用 context.write() 方法，就可以确保内容被发送到顶层的缓冲区。

上下文变量

当模板被编译为 python 模块时，其页面内容被包含在 render_body 这个函数中。其他顶层的 defs, 会在其各自独立的函数中定义，函数名被附加了一个前缀 "render_"（比如 render_mydef）。在这些函数中，所有在本地没有定义的变量（比如通过赋值或模块导入的方式定义的），都会从 Context 对象的变量字典中提取。
      如果引用当前上下文中不存在的变量会怎么样？ - 你取得的值将是一个特殊的值 UNDEFINED. 它是 mako.runtime.Undefined 类的一个全局变量。UNDEFINED 对象会在你尝试调用 str() 时抛出错误。这会在尝试在表达式中使用它的时候发生。
      为什么不直接返回 None 呢？ UNDEFINED 更明确，可以和人为传递到 Context 中的 None 加以区分，以及和没有提供值的变量区分开来。
      为什么对它调用 str() 时会引发异常，而不是返回空字符串呢？ - Mako 一直在努力遵循 python 的哲学 “明确胜于隐晦”(explicit is better than implicit). 具体来说，模板作者应该处理值丢失的情况，而不是默默的任由其出错。因为 UNDEFINED 和 python 的 True 或 False 一样，是个单件(Singleton) 对象，你可以用 is 运算符来检查它： 
% if someval is UNDEFINED:
	someval is:no value
% else:
	someval is:${someval}
% endif
另一个值得注意的方面是，Context 的变量字典是不可变的。当然，因为是纯 python 的方式，你可以修改 context 的变量字典中的变量，但这恐怕不会如你想像。原因是，Mako 会在很多情况下会创建 Context 对象的副本，并将这些副本传递给模板中的各种元素，以及执行过程中可能用到的子模板。所以，修改本地 Context 中的值，不一定会在模板的其他部分生效。Mako 创建 Context 副本的一个例子是，在模板体中进行对顶层 def 的调用（context 被用于传递局部变量到 def 的范围中；因为在模板体内，他们以内联函数的形式出现，Mako 会尝试让他们用这种方式工作）。另一个例子是在继承链中（在链中的每个模板都有其不同的 parent 和 next，而这两个变量就保存在各自唯一的 Context 对象中）。
    * 那么，我们如何设定相对于一个模板请求过程的全局变量呢？ - 只要在模板初次运行时给 Context 提供一个字典即可，然后所有的地方就都可以向该字典中 get/set 变量了。比如叫做 attributes： 
##<%
##    attributes['foo'] = 'bar'
##%>
##'foo' attribute is: ${attributes['foo']}
    * 为什么"attributes" 不是 Context 的内建特性呢？ - 这也是 Mako 替你的应用程序尽量少做决定的一个体现。也许你不想在模板里用这种技术读写和共享数据，又或者你想用不同的变量名或数据结构来传递。再一次的，Mako 宁愿用户明确一点。 
    