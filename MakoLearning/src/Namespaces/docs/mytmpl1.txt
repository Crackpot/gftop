##coding=utf-8
Namespaces from Regular Python Modules

Namespaces can also import regular Python functions from modules. These callables need to take at least one argument, context:

A module file some/module.py might contain the callable: 
<%namespace name="hw" module="some.module"/>
${hw.my_tag()}
Note that the context argument is not needed in the call; the namespace tag creates a locally-scoped callable which takes care of it.

Declaring defs in namespaces.

The <％namespace> tag supports the definition of <％defs> directly inside the tag. These defs become part of the namespace like any other function, and will override the definitions pulled in from a remote template or module:
  
## define a namespace
<%namespace name="stuff">
	<%def name="comp1()">
		comp1
	</%def>
</%namespace>
## then call it
${stuff.comp1()}



The "body()" method

Every namespace that is generated from a template contains a method called body(). This method corresponds to the main body of the template, and plays its most important roles when using inheritance relationships as well as def-calls-with-content.

Since the body() method is available from a namespace just like all the other defs defined in a template, what happens if you send arguments to it ? By default, the body() method accepts no positional arguments, and for usefulness in inheritance scenarios will by default dump all keyword arguments into a dictionary called pageargs. But if you actually want to get at the keyword arguments, Mako recommends you define your own argument signature explicitly. You do this via using the <％page> tag: 

<%page args="x=1, y=2, someval=8, scope='foo', **kwargs"/>

A template which defines the above signature requires that the variables x and y are defined, defines default values for someval and scope, and sets up **kwargs to receive all other keyword arguments. If **kwargs or similar is not present, the argument **pageargs gets tacked on by Mako. When the template is called as a top-level template (i.e. via template.render()) or via the <％include> tag, the values for these arguments will be pulled from the Context. In all other cases, i.e. via calling the body() method, the arguments are taken as ordinary arguments from the method call. So above, the body might be called as: 

$｛self.body(5, y=10, someval=15, delta=7)｝

The Context object also supplies a kwargs accessor, for cases when youd like to pass along whatever is in the context to a body() callable: 

$｛next.body(**context.kwargs)｝
The usefulness of calls like the above become more apparent when one works with inheriting templates. For more information on this, as well as the meanings of the names self and next, see Inheritance. 