目录


第1章  Java概述       1
    1.1  Java语言的发展简史   2
    1.2  Java的竞争对手及各自优势      4
        1.2.1  C#简介和优势   4
        1.2.2  Ruby简介和优势      4
        1.2.3  Python的简介和优势       5
    1.3  Java程序运行机制      5
        1.3.1  高级语言的运行机制       6
        1.3.2  Java程序的运行机制和JVM   6
    1.4  开发Java的准备  7
        1.4.1  安装JDK   8
            学生提问：不是说JVM是运行Java程序的虚拟机吗？那JRE和JVM的关系是怎样的呢？   8
            学生提问：为什么不安装公共JRE系统呢？   9
        1.4.2  设置PATH环境变量 10
            学生提问：为什么选择设置用户变量，用户变量和系统变量有什么区别呢？    11
    1.5  第一个Java程序  12
        1.5.1  编辑Java源代码      12
        1.5.2  编译Java程序   13
            学生提问：当我们使用编译C程序时，不仅需要指定存放目标文件的位置，也需要指定目标文件的文件名，这里使用javac编译Java程序时怎么不需要指定目标文件的文件名呢？   13
        1.5.3  运行Java程序   14
        1.5.4  根据CLASSPATH环境变量定位类       15
    1.6  Java程序的基本规则   16
        1.6.1  Java程序的组织形式       16
        1.6.2  Java源文件的命名规则   17
        1.6.3  初学者容易犯的错误       18
    1.7  垃圾回收机制      20
    1.8  何时开始使用IDE工具      21
        学生提问：老师，我想学习Java编程，到底是学习Eclipse好呢，还是学习JBuilder好呢？  21
    1.9  本章小结      22
    本章练习       22

第2章  理解面向对象       23
    2.1  面向对象      24
        2.1.1  结构化程序设计简介       24
        2.1.2  程序的三种基本结构       25
        2.1.3  面向对象程序设计简介   27
        2.1.4  面向对象的基本特征       28
    2.2  UML（统一建模语言）介绍      29
        2.2.1  用例图       30
        2.2.2  类图   31
        2.2.3  组件图       33
        2.2.4  部署图       33
        2.2.5  顺序图       34
        2.2.6  活动图       34
        2.2.7  状态机图   36
    2.3  Java的面向对象特征   36
        2.3.1  一切都是对象   37
        2.3.2  类和对象   37
    2.4  本章小结      37

第3章  数据类型和运算符       38
    3.1  注释      39
        3.1.1  单行注释和多行注释       39
        3.1.2  文档注释   40
            学生提问：API文档是什么?      40
            学生提问：为什么要掌握查看API文档的方法？   42
    3.2  标识符和关键字   45
        3.2.1  分隔符       45
        3.2.2  标识符规则       47
        3.2.3  Java关键字       47
    3.3  数据类型分类      48
    3.4  基本数据类型      48
        3.4.1  整型   49
        3.4.2  字符型       49
        3.4.3  浮点型       51
        3.4.4  布尔型       52
    3.5  基本类型的类型转换   53
        3.5.1  自动类型转换   53
        3.5.2  强制类型转化   54
        3.5.3  表达式类型的自动提升   56
    3.6  直接量   57
        3.6.1  直接量的类型   57
        3.6.2  直接量的赋值   58
    3.7  运算符   58
        3.7.1  算术运算符       58
        3.7.2  赋值运算符       61
        3.7.3  位运算符   62
        3.7.4  扩展后的赋值运算符       64
        3.7.5  比较运算符       65
            学生提问：Java为什么要对这些数据进行缓存呢?  67
        3.7.6  逻辑运算符       67
        3.7.7  三目运算符       68
        3.7.8  运算符的结合性和优先级       69
    3.8  本章小结      70
    本章练习       70

第4章  流程控制和数组    71
    4.1  顺序结构      72
    4.2  分支结构      72
        4.2.1  if条件语句       72
        4.2.2  switch分支语句 76
    4.3  循环结构      78
        4.3.1  while循环语句  78
        4.3.2  do while循环语句    79
        4.3.3  for循环     80
        4.3.4  嵌套循环   83
    4.4  控制循环结构      84
        4.4.1  使用break结束循环 84
        4.4.2  使用continue结束本次循环    86
        4.4.3  使用return结束方法       87
    4.5  数组类型      87
        4.5.1  理解数组：数组也是一种类型       88
            学生提问：int[]是一种类型吗？怎么使用这种类型呢？ 88
        4.5.2  定义数组   88
        4.5.3  数组的初始化   89
            学生提问：能不能只分配内存空间，不赋初始值呢？89
        4.5.4  使用数组   90
            学生提问：为什么要我记住这些异常信息？    91
        4.5.5  JDK1.5提供了foreach循环    91
    4.6  深入数组      93
        4.6.1  内存中的数组   93
            学生提问：为什么有栈内存和堆内存之分？    93
        4.6.2  基本类型数组的初始化   95
        4.6.3  引用类型数组的初始化   96
        4.6.4  没有多维数组   99
            学生提问：我是否可以让图4.13中灰色覆盖的数组元素再次指向另一个数组？这样不可以扩展成三维数组吗？甚至扩展到更多维的数组？    101
        4.6.5  操作数组的工具类   102
        4.6.6  数组的应用举例       103
    4.7  本章小结      106
    本章练习       106

 

第5章  面向对象（上）	107
5.1  类和对象	108
5.1.1  定义类	108
学生提问：构造器不是没有返回值吗？为什么不能用void修饰呢？	110
5.1.2  对象的产生和使用	110
5.1.3  对象、引用和指针	111
5.1.4  对象的this引用	112
5.2  方法详解	116
5.2.1  方法的所属性	116
5.2.2  方法的参数传递机制	116
5.2.3  形参长度可变的方法	120
5.2.4  递归方法	121
5.2.5  方法重载	123
学生提问：为什么方法的返回值类型不能用于区分重载的方法？	124
5.3  成员变量和局部变量	124
5.3.1  成员变量和局部变量	125
5.3.2  成员变量的初始化和内存中的运行机制	128
5.3.3  局部变量的初始化和内存中的运行机制	130
5.3.4  变量的使用规则	130
5.4  隐藏和封装	132
5.4.1  理解封装	132
5.4.2  使用访问控制符	132
5.4.3  package和import	135
5.4.4  Java的常用包	140
5.5  深入构造器	140
5.5.1  使用构造器执行初始化	141
学生提问：构造器是创建Java对象的途径，是不是说构造器完全负责创建Java对象？	141
5.5.2  构造器的重载	142
学生提问：为什么要用this来调用另一个重载的构造器？我把另一个构造器里的代码复制、粘贴到这个构造器里不就可以了吗？	143
5.6  类的继承	144
5.6.1 继承的特点	144
5.6.2  重写父类的方法	145
5.6.3  父类实例的super引用	146
学生提问：我们只是创建了一个Ostrich对象时，哪来的Bird对象？	147
5.6.4  调用父类构造器	148
学生提问：为什么我创建Java对象时从未感觉到java.lang.Object的构造器被调用过？	150
5.7  多态	151
5.7.1  多态性	151
5.7.2  引用变量的强制类型转换	152
5.7.3  instanceof运算符	154
5.8  继承与组合	154
5.8.1  使用继承的注意点	155
5.8.2  利用组合实现复用	156
学生提问：使用组合关系来实现复用时，需要创建两个Animal对象，是不是意味着使用组合关系时系统开销更大？	159
5.9  初始化块	159
5.9.1  使用初始化块	160
5.9.2  初始化块和构造器	161
5.9.3  静态初始化块	162
5.10  本章小结	165
本章练习	165
第6章  面向对象（下）	166
6.1  基本数据类型的包装类	167
6.2  处理对象	170
6.2.1  打印对象和toString方法	170
6.2.2  ==和equals比较运算符	172
6.3  类成员	175
6.3.1  理解类成员	175
6.3.2  单例（Singleton）类	176
6.4  final修饰符	177
6.4.1  final变量	177
6.4.2  final方法	181
6.4.3  final类	182
6.4.4  不可变类	182
6.4.5  缓存实例的不可变类	186
6.5  抽象类	188
6.5.1  抽象方法和抽象类	188
6.5.2  抽象类的作用	191
6.6  更彻底的抽象：接口	192
6.6.1  接口的概念	192
6.6.2  接口的定义	193
6.6.3  接口的继承	195
6.6.4  使用接口	195
6.6.5  接口和抽象类	197
6.6.6  面向接口编程	198
6.7  内部类	202
6.7.1  非静态内部类	202
学生提问：非静态内部类对象和外部类对象的关系是怎样的？	206
6.7.2  静态内部类	207
学生提问：为什么静态内部类实例方法也不能访问外部类的实例属性呢？	207
学生提问：接口里是否能定义内部接口？	208
6.7.3  使用内部类	208
学生提问：既然内部类是外部类的成员，是否可以为外部类定义子类，在子类中再定义一个内部类来重写其父类中的内部类？	211
6.7.4  局部内部类	211
6.7.5  匿名内部类	212
6.7.6  闭包（Closure）和回调	215
6.8  枚举类	217
6.8.1  手动实现枚举类	217
6.8.2  枚举类入门	219
6.8.3  枚举类的属性、方法和构造器	220
6.8.4  实现接口的枚举类	223
6.8.5  包含抽象方法的枚举类	224
6.9  对象与垃圾回收	225
6.9.1  对象在内存中的状态	226
6.9.2  强制垃圾回收	227
6.9.3  finalize方法	228
6.9.4  对象的软、弱和虚引用	230
6.10  修饰符的适用范围	233
6.11  使用JAR文件	234
6.11.1  jar命令详解	235
6.11.2  创建可执行的JAR包	237
6.11.3  关于JAR包的技巧	238
6.12  本章小结	239
本章练习	239
第7章  Java集合	240
7.1  Java集合概述	241
7.2  Collection和Iterator接口	243
7.2.1  使用Iterator接口遍历集合元素	244
7.2.2  使用foreach循环遍历集合元素	246
7.3  Set接口	247
7.3.1  HashSet类	247
学生提问：hashCode方法对于HashSet的作用是什么？	249
7.3.2  TreeSet类	252
7.3.3  EnumSet类	259
7.4  List接口	261
7.4.1  List接口和ListIterator接口	261
7.4.2  ArrayList和Vector实现类	264
7.4.3  固定长度的List	266
7.5  Queue接口	266
7.5.1  LinkedList实现类	266
7.5.2  PriorityQueue实现类	269
7.6  Map	270
7.6.1  HashMap和Hashtable实现类	271
7.6.2  SortedMap接口和TreeMap实现类	276
7.6.3  WeakHashMap实现类	279
7.6.4  IdentityHashMap实现类	280
7.6.5  EnumMap实现类	281
7.7  HashSet和HashMap的性能选项	282
7.8  操作集合的工具类：Collections	283
7.8.1  排序操作	283
7.8.2  查找，替换操作	287
7.8.3  同步控制	288
7.8.4  设置不可变集合	288
7.9  烦琐的接口：Enumeration	289
7.10  本章小结	290
本章练习	290
第8章  泛型	291
8.1  泛型入门	292
8.1.1  编译时不检查类型的异常	292
8.1.2  手动实现编译时检查类型	293
8.1.3  使用泛型	294
8.2  深入泛型	294
8.2.1  定义泛型接口、类	295
8.2.2  从泛型类派生子类	296
8.2.3  并不存在泛型类	298
8.3  类型通配符	298
8.3.1  使用类型通配符	300
8.3.2  设定类型通配符的上限	300
8.3.3  设定类型形参的上限	302
8.4  泛型方法	303
8.4.1  定义泛型方法	303
8.4.2  泛型方法和类型通配符的区别	306
8.4.3  设定通配符的下限	307
8.4.4  泛型方法与方法重载	309
8.5  擦除和转换	310
8.6  泛型与数组	311
8.7  本章小结	313
第9章  与运行环境交互	314
9.1  与用户互动	315
9.1.1  运行Java程序的参数	315
9.1.2  使用Scanner获取键盘输入	316
9.1.3  使用BufferedReader获取键盘输入	318
9.2  系统相关	319
9.2.1  System类	319
9.2.2  Runtime类	321
9.3  常用类	322
9.3.1  Object类	322
9.3.2  String、StringBuffer和StringBuilder类	322
9.3.3  Math类	327
9.3.4  Random类	328
9.3.5  BigDecimal类	330
9.4  处理日期的类	333
9.4.1  Date类	333
9.4.2  Calendar类	334
9.4.3  TimeZone类	337
9.5  正则表达式	338
9.5.1  创建正则表达式	338
9.5.2  使用正则表达式	341
9.6  程序国际化	345
9.6.1  Java国际化的思路	346
9.6.2  Java支持的语言和国家	346
9.6.3  完成程序国际化	347
9.6.4  使用MessageFormat处理包含占位符的字符串	349
9.6.5  使用类文件代替资源文件	350
9.6.6  使用NumberFormat格式化数字	350
9.6.7  使用DateFormat格式化日期	352
9.7  本章小结	355
本章练习	355
第10章  异常处理	356
10.1  异常概述	357
10.2  异常处理机制	358
10.2.1  使用try...catch捕获异常	359
10.2.2  异常类的继承体系	360
10.2.3  访问异常信息	363
10.2.4  使用finally回收资源	364
10.2.5  异常处理的嵌套	367
10.3  Checked异常和Runtime异常体系	367
10.3.1  使用throws声明抛出异常	367
10.4  使用throw抛出异常	369
10.4.1  抛出异常	369
10.4.2  自定义异常类	371
10.4.3  catch和throw同时使用	371
10.4.4  异常链	373
10.5  Java的异常跟踪栈	374
10.6  异常处理规则	376
10.6.1  不要过度使用异常	377
10.6.2  不要使用过于庞大的try块	378
10.6.3  避免使用Catch All语句	378
10.6.4  不要忽略捕获到的异常	379
10.7  本章小结	379
本章练习	379
第11章  AWT编程	380
11.1  GUI（图形用户界面）和AWT	381
11.2  AWT容器	382
11.3  布局管理器	385
11.3.1  FlowLayout布局管理器	386
11.3.2  BorderLayout布局管理器	387
学生提问：BorderLayout最多只能放置5个组件吗？那它还有什么作用？	388
11.3.3  GridLayout布局管理器	389
11.3.4  GridBagLayout布局管理器	390
11.3.5  CardLayout布局管理器	393
11.3.6  绝对定位	395
11.3.7  BoxLayout布局管理器	396
学生提问：图11.15和图11.16显示的所有按钮都紧挨在一起，如果希望像FlowLayout、GridLayout等布局管理器指定组件的间距该怎么办？	397
11.4  AWT 常用组件	398
11.4.1  基本组件	398
11.4.2  对话框	400
11.5  事件处理	403
11.5.1  Java事件模型的流程	403
11.5.2  事件和事件监听器	405
11.5.3  事件适配器	409
11.5.4  事件监听器的实现形式	411
11.6  AWT的菜单	413
11.6.1  菜单条、菜单和菜单项	414
11.6.2  右键菜单	416
学生提问：为什么即使我没有给多行文本域编写右键菜单，但当我在多行文本域上单击右键时一样会弹出右键菜单？	418
11.7  在AWT中绘图	418
11.7.1  画图的实现原理	418
11.7.2  使用Graphics类	419
11.8  处理位图	425
11.8.1  Image抽象类和BufferedImage实现类	425
11.8.2  使用ImageIO输入/输出位图	427
11.9  剪贴板	432
11.9.1  数据传递的类和接口	432
11.9.2  传递文本	433
11.9.3  使用系统剪贴板传递图像	435
11.9.4  使用本地剪贴板来传递对象引用	439
11.9.5  通过系统剪贴板传递Java对象	442
11.10  本章小结	445
本章练习	445
第12章  Swing编程	446
12.1  Swing概述	447
12.2  Swing基本组件的用法	448
12.2.1  Swing组件层次	448
12.2.2  AWT组件的Swing实现	449
学生提问：为什么单击Swing多行文本域时不是弹出像AWT多行文本域中的右键菜单？	455
12.2.3  使用JToolBar创建工具条	458
12.2.4  使用JColorChooser和JFileChooser 461
12.2.5  使用JOptionPane	469
12.3  Swing中的特殊容器	475
12.3.1  使用JSplitPane	475
12.3.2  使用JTabbedPane	477
12.3.3  使用JLayeredPane、JDesktopPane和JInternalFrame	481
12.4  Swing拖放功能	490
12.4.1  拖放目标	491
12.4.2  拖放源	494
12.4.3  简化的拖放操作	495
12.5  Applet和JApplet	497
12.5.1  Applet简介及其安全性	498
12.5.2  开发Applet类	498
12.5.3  使用HTML页面装载Applet	500
12.5.4  appletviewer简介	502
12.5.5  Applet的生命周期和动画机制	503
学生提问：程序中重写paint方法时绘制了一个字符串，但图12.28上则绘制出了如此之多的字符串，这是为什么呢?	505
12.5.6  使用Applet创建音乐播放器	505
12.6  使用JProgressBar、ProgressMonitor和BoundedRangeModel创建进度条	508
12.6.1  创建进度条	508
12.6.2  创建进度对话框	512
12.7  使用JSlider和BoundedRangeModel创建滑动条	513
12.8  使用JSpinner和SpinnerModel创建微调控制器	517
12.9  使用JList、JComboBox创建列表框	520
12.9.1  简单列表框	520
12.9.2  不强制存储列表项的ListModel和ComboBoxModel	524
12.9.3  强制存储列表项的DefaultListModel和DefaultComboBoxModel	528
学生提问：为什么JComboBox提供了添加、删除列表项目的方法？而JList没有提供添加、删除列表项的方法呢？	530
12.9.4  使用ListCellRenderer改变列表项外观	530
12.10  使用JTree和TreeModel创建树	532
12.10.1  创建树	533
12.10.2  拖动、编辑树节点	536
12.10.3  监听节点事件	540
12.10.4  使用TreeCellRendering改变节点外观	542
12.11  使用JTable和TableModel创建表格	549
12.11.1  创建JTable	549
学生提问：我们指定的表格数据、表格列标题都是Object类型的数组，JTable如何显示这些Object对象？550
12.11.2  TableModel和监听器	555
12.11.3  TableColumnModel和监听器	561
12.11.4  实现排序	564
12.11.5  绘制单元格内容	567
12.11.6  编辑单元格内容	570
12.12  使用JFormattedTextField和JTextPane创建格式文本	576
12.12.1  监听Document的改变	576
12.12.2  使用JPasswordField	578
12.12.3  使用JFormattedTextField	579
12.12.4  使用JEditorPane	588
12.12.5  使用JTextPane	588
12.13  本章小结	595
本章练习	595
第13章  JDBC编程	596
13.1  JDBC基础	597
13.1.1  JDBC简介	597
13.1.2  JDBC驱动程序类型	598
13.2  SQL语法介绍	599
13.2.1  安装数据库	599
13.2.2  关系数据库基本概念和MySQL基本命令	601
13.2.3  SQL语句基础	603
13.2.4  DDL语句	604
13.2.5  DML语句语法	618
13.2.6  select语句和SQL函数	620
13.2.7  分组和组函数	627
13.2.8  多表连接查询和子查询	629
13.3  JDBC的典型用法	635
13.3.1  JDBC常用接口和类简介	635
13.3.2  JDBC编程步骤	637
学生提问：前面给出的仅是MySQL和Oracle两种数据库的驱动，我看不出驱动类字符串有什么规律啊。如果我希望使用其他数据库，我怎么用其他数据库的驱动类呢？637
13.4  执行SQL语句的方式	639
13.4.1  使用executeUpdate执行DDL和DML语句	640
13.4.2  使用execute方法执行SQL语句	642
13.4.3  使用PreparedStatement执行SQL语句	644
13.4.4  使用CallableStatement调用存储过程	650
13.5  管理结果集	652
13.5.1  可滚动、可更新的结果集	652
13.5.2  处理Blob类型数据	654
13.5.3  使用ResultSetMetaData分析结果集	660
13.6  事务处理	663
13.6.1  事务的概念和MySQL事务支持	663
13.6.2  JDBC的事务支持	665
13.6.3  批量更新	667
13.7  分析数据库信息	668
13.7.1  使用DatabaseMetaData分析数据库信息	668
13.7.2  使用系统表分析数据库信息	670
13.7.3  选择合适的分析方式	671
13.8  使用连接池管理连接	671
13.9  本章小结	673
本章练习	673
第14章  Annotation（注释）	674
14.1  基本Annotation	675
14.1.1  限定重写父类方法：@Override	675
14.1.2  标示已过时：@Deprecated	676
14.1.3  抑制编译器警告：@SuppressWarnings 677
14.2  自定义Annotation	677
14.2.1  定义Annotation	677
14.2.2  提取Annotation的信息	679
14.2.3  使用Annotation的例子	680
14.3  JDK的元Annotation	685
14.3.1  使用@Retention	685
14.3.2  使用@Target	686
14.3.3  使用@Documented	686
14.3.4  使用@Inherited	687
14.4  使用APT处理Annotation	688
14.5  本章小结	693
第15章  输入/输出	694
15.1  File类	695
15.1.1  访问文件和目录	695
15.1.2  文件过滤器	697
15.2  理解Java的IO流	698
15.2.1  流的分类	698
15.2.2  流的概念模型	699
15.3  字节流和字符流	700
15.3.1  InputStream和Reader	701
15.3.2  OutputStream和Writer	703
15.4  输入/输出流体系	705
15.4.1  处理流的用法	705
15.4.2  输入/输出流体系	706
15.4.3  转换流	708
学生提问：怎么没有把字符流转换成字节流的转换流呢？	708
15.4.4  推回输入流	710
15.5  重定向标准输入/输出	711
15.6  Java虚拟机读写其他进程的数据	713
15.7  RandomAccessFile	716
15.8  对象序列化	720
15.8.1  序列化的含义和意义	720
15.8.2  使用对象流实现序列化	720
15.8.3  对象引用的序列化	723
15.8.4  自定义序列化	728
15.8.5  另一种自定义序列化机制	733
15.8.6  版本	735
15.9  Java新IO	736
15.9.1  Java新IO概述	736
15.9.2  使用Buffer	737
15.9.3  使用Channel	740
15.9.4  编码集和Charset	743
15.9.5  文件锁	745
15.10  本章小结	747
本章练习	747
第16章  多线程	748
16.1  线程概述	749
16.1.1  线程和进程	749
16.1.2  多线程的优势	750
16.2  线程的创建和启动	750
16.2.1  继承Thread类创建线程类	751
16.2.2  实现Runnable接口创建线程类	752
16.2.3  两种方式所创建线程的对比	754
16.3  线程的生命周期	754
16.3.1  新建和就绪状态	754
16.3.2  运行和阻塞状态	756
16.3.3  线程死亡	757
16.4  控制线程	758
16.4.1  join线程	758
16.4.2  后台线程	759
16.4.3  线程睡眠：sleep	760
16.4.4  线程让步：yield	761
16.4.5  改变线程优先级	762 
16.5  线程的同步	764
16.5.1  线程安全问题	764
16.5.2  同步代码块	766
16.5.3  同步方法	767
16.5.4  释放同步监视器的锁定	770
16.5.5  同步锁（Lock）	770
16.5.6  死锁	772
16.6  线程通信	774
16.6.1  线程的协调运行	774
16.6.2  使用条件变量控制协调	778
16.6.3  使用管道流	780
16.7  线程组和未处理的异常	782
16.8  Callable和Future	785
16.9  线程池	787
16.10  线程相关类	789
16.10.1  ThreadLocal类	789
16.10.2  包装线程不安全的集合	791
16.10.3  线程安全的集合类	792
16.11  本章小结	792
第17章  网络编程	793
17.1  网络编程的基础知识	794
17.1.1  网络基础知识	794
17.1.2  IP地址和端口号	795
17.2  Java的基本网络支持	796
17.2.1  使用InetAddress	796
17.2.2  使用URLDecoder和URLEncoder	797
17.2.3  使用URL和URLConnection	798
17.3  基于TCP协议的网络编程	806
17.3.1  TCP协议基础	806
17.3.2  使用ServletSocket创建TCP服务器端	807
17.3.3  使用Socket进行通信	807
17.3.4  加入多线程	810
17.3.5  记录用户信息	813
17.3.6  使用NIO实现非阻塞Socket通信	823
17.4  基于UDP协议的网络编程	829
17.4.1  UDP协议基础	829
17.4.2  使用DatagramSocket发送、接收数据	829
17.4.3  使用MulticastSocket实现多点广播	834
17.5  使用代理服务器	845
17.5.1  直接使用Proxy创建连接	845
17.5.2  使用ProxySelector选择代理服务器	847
17.6  本章小结	849
本章练习	849
第18章  类加载和反射	850
18.1  类的加载、连接和初始化	851
18.1.1  JVM和类	851
18.1.2  类的加载	852
18.1.3  类的连接	853
18.1.4  类的初始化	853
18.1.5  类初始化的时机	854
18.2  类加载器	855
18.2.1  类加载器简介	856
18.2.2  类加载机制	857
18.2.3  创建并使用自定义的类加载器	858
18.2.4  URLClassLoader类	862
18.3  通过反射查看类信息	863
18.3.1  获得Class对象	863
18.3.2  从Class中获取信息	864
18.4  使用反射生成并操作对象	868
18.4.1  创建对象	868
18.4.2  调用方法	870
18.4.3  访问属性值	873
18.4.4  操作数组	874
18.5  使用反射生成JDK动态代理	875
18.5.1  使用Proxy和InvocationHandler创建动态代理	876
18.5.2  动态代理和AOP	878
18.6  反射和泛型	882
18.6.1  泛型和Class类	882
18.6.2  使用反射来获取泛型信息	884
18.7  本章小结	885
本章练习	886
上善若水——兼谈我的创作理念	887
