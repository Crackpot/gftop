#!/usr/bin/env python
#coding=utf-8

li=["a", "b", "mpilgrim", "z", "example"]   #定义了一个有5个元素的列表。它们保持着它们初始的顺序。
print "列表为：", li
print "列表中的第1个元素li[0]为：", li[0] #一个列表可以象一个以0开始的数组一样使用。任何一个非空列表的第一个元素总是 li[0]。
print "列表中的第5个元素li[4]为：", li[4] #这个5元素列表的最后一个元素是 li[4]，因为列表总是从0开始。
print "负的列表索引："
print "列表中的倒数第1个元素li[－1]为：", li[-1] 
print "列表中的倒数第3个元素li[－3]为：", li[-3] 
print "分割列表："
print "下标1与3之间的元素li[1:3]为：", li[1:3]    #通过指定2个索引得到列表的子集，叫做一个“分片”。返回值是一个新的列表，它包含了列表中按顺序从第一个分片索引(这里为 li[1])开始，直到但是不包括第二个分片索引(这里为 li[3])的所有元素。
print "下标1与－1之间的元素li[1:-1]为：", li[1:-1]
#如果一个或两个分片索引是负数，分片也可以工作。从左向右阅读列表，第一个分片索引指定了你想要的第一个元素，第二个分片索引指定了第一个你不想要的元素。返回的值为在其间的每个元素。
print "下标0与3之间的元素li[0:3]为：", li[0:3]    #列表从0开始，所以 li[0:3] 返回列表的前3个元素，开始从 li[0]，直到但不包括 li[3]。
print "分片缩写:"
print li    #显示列表中的所有元素
print "列表中下标从0到3间的元素li[:3]为：", li[:3]    #如果任一个分片索引为0，你可以将其省略，默认为0。所以 li[:3] 同 li[0:3] 一样。
print "列表中下标从3到末尾间的元素li[3:]为：", li[3:]  #在这个5元素列表中，li[:3] 返回前三个元素，而 li[3:] 返回后两个元素。实际上，li[:n] 将总是返回前 n 个元素，而 li[n:] 将返回其它的元素。
print "列表中的所有元素li[:]为：", li[:]  #如果两个分片索引均省略，将包括列表的所有元素。但是与原始的列表 li 不是同一个，它是一个新的列表，恰好拥有与 li 全部一样的元素。li[:] 是生成一个列表拷贝的缩写。
print "向列表中增加元素："
print "通过li.append(\"new\")向列表中的尾部添加元素\"new\""
li.append("new")    #append 增加单个元素到列表的尾部。
print "列表中的所有元素：", li
print "通过li.insert(2, \"new\")向列表中指定位置插入元素"
li.insert(2, "new")     #insert 在列表中插入单个元素。数值参数是使得列表增加的第一个元素的索引     注意列表元素不需要唯一，现在有两个独立的元素拥有 new 这个值，li[2] 和 li[6]。
print "列表中的所有元素：", li
print "通过li.extend([\"two", "dlements\"])连接两个列表"
li.extend(["two", "elements"])  #extend 连接列表。注意不要用多个参数调用 extend ，要使用一个列表参数调用。在这种情况下，列表有两个元素。
print li
print "搜索列表："
print "通过li.index(\"example\")方法得到列表中第一个值为\"example\"的下标为：", li.index("example")    #index 在列表中查找值第一次的出现并返回索引值。
print "通过li.index(\"new\")得到列表中第一个值为\"new\"的下标为：",  li.index("new")    #index 在列表中查找值 第一次 的出现。在本例中， new 在列表中出现了两次，在 li[2] 和li[6]，但是 index 将只返回第一个索引，2。
# print li.index("c")   如果在列表中没有找到值，Python会引发一个异常。这一点与大部分的语言相当不同，大部分语言将会返回某个无效索引。尽管这种处理可能看上去令人讨厌，它仍然是好东西，因为它说明你的程序会由于源代码的问题而崩溃，好于在后面当你使用无效索引而引起崩溃。
print "元素\"c\"在列表li中么？","c" in li   #要测试一个值是否在列表内，使用 in，如果值找到了，它返回 1 ，或者没找到则为 0 。在Python中不存在布尔类型。在一个布尔上下文中(象 if 语句)，0 是假，所有其它的数值为真。这一点也可以扩展到其它类型。一个空串("")，一个空列表([])，和一个空字典({})都是假，所有其它的字符串，列表，和字典是真。
if "c" in li:
    print li.index("c")
else:
    print "列表中没有元素\"c\""
print "从列表中除去元素:"
print "列表为：", li
print "通过li.remove(\"z\")删除列表li中第一个值为\"z\"的元素"
li.remove("z")  #remove 从列表中除掉第一次出现的值。
print "删除\"z\"元素后的列表为：", li
li.remove("new")    #remove 仅 除掉第一次出现的值。在本例中，new 在列表中出现了两次，但是 li.remove("new") 仅除掉了第一次出现的值。
print "删除\"new\"元素后的列表为：", li, "此时列表中还有一个\"new\"元素"
if "c" in li:
    li.remove("c")  #如果在列表中没有找到值，Python引发一个异常。它反映了 index 方法的行为。
else :
    print "列表中没有\"c\"元素，删除\"c\"元素失败"
print li.pop()  #pop 是一个有趣的东西。它执行两件事：除掉列表的最后一个元素，然后返回除掉的值。注意这一点同 li[-1]不同，后者返回一个值但不改变列表，也不同于 li.remove(value)，后者改变列表但不返回值。
print "执行li.pop()删除列表中最后一个元素之后列表为：", li
print "列表操作符："
li=['a', 'b', 'mpilgrim']
print "列表li为：",li
li=li+['example', 'new']    #列表也可以用 + 操作符连接起来。list = list + otherlist 相当于 list.extend(otherlist)。但是 + 操作符将连接后的列表作为一个值返回，而 extend 仅修改存在的列表。
print "通过li=li+[\'example\', \'new\']操作增加之后的列表li为：", li
li+=['two']     #Python支持 += 操作符。li += ['two'] 相当于 li = li + ['two']。+= 操作符可用于列表，字符串，和整数，并且它也可以在用户定义类中被重载。(第三章会有更多的类)
print "通过li+=[\'two\']操作之后列表li为：", li
li=[1, 2]*3     #* 操作符作为一个重复符可用在列表上。li = [1, 2] * 3 相当于 li = [1, 2] + [1, 2] + [1, 2]， 将三个列表连成一个。
print "通过li=[1, 2]*3操作之后列表li为：", li
